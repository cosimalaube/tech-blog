---
layout: post
title: The State of Property-Based Testing in JavaScript
categories: slackday
---

## Introduction

Property-based testing is a testing method based on (pseudo-)randomly generated input. It can be used at any level
of the testing pyramid to validate some properties of the algorithms or systems we built. To create a test case
you need to define the following parts:

- **Unit under test**: E.g. a function, endpoint in your API
- **Input generator function**: A function that will generate pseudo-random input for your test case (based on a seed)
- **A property predicate**: A predicate that has to hold true for all inputs generated by the generator function

The test runner will then roughly do the following when executing your test:

1. It will seed your generator function with a random seed. This is necessary to make the results reproducible
1. It will feed the next output of your generator function into your unit-under-test
1. It will check whether the output of your unit-under-test passes the property predicate
   - If false: fail test
   - If true: continue with 2. (until some number of iterations is reached)

A simple example for a property based test would be the following property based test for the plus function (for
simplicity's sake I left out the seed part of the generator function). This property-based test tests whether the
sum of two positive numbers is always positive:

- **Unit under test**: `add = (x, y) => x + y`
- **Input generator function**: `() => Math.random() * 100000` (generates a number `< 100000` and `>= 0`)
- **Property predicate**: `(in1, in2) => add(in1, in2) >= 0`

The advantage of this type of testing is that your function will be tested with way more input values compared to testing
with regular unit tests. This allows you to find edge cases where your unit-under-test does not behave as you would expect
it to. This is quite similar to Fuzzing in the IT-Security community, where the goal is to find security issues or memory
leaks by providing (invalid) random data.

A disadvantage is that, depending on the unit-under-test, the properties can be quite hard to define. For the simple
plus example from before it was quite easy, but different algorithms have different properties and they are often very unique
to the unit-under-test. Another drawback is that property-based testing does not guaranteed to find any existing issues with any
test-run. The goal is rather to find them eventually by generating enough random data.

## Property-Based Testing in JavaScript

### Overview

In other languages like Haskell ([quickcheck](https://hackage.haskell.org/package/QuickCheck)) and 
Clojure ([test.check](https://github.com/clojure/test.check)) there is a de-facto standard for property based testing.
In the JavaScript world this is not yet the case. I found few frameworks that are actively develop and have a
substantial amount of users (> 1000 downloads per month on npm) 

- [jsverify](https://github.com/jsverify/jsverify): A library highly inspired by *Haskells QuickCheck*
- [quick_check](https://github.com/gampleman/quick_check.js): An implementation of *Haskells QuickCheck* in JavaScript
- [testcheck](https://github.com/leebyron/testcheck-js): A library that is a thin wrapper around *ClojureScripts test.check*

To be able to compare those frameworks, we will test the implementation of
[Array.prototype.filter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter):

```
function filter(fn, array) {
    return array.filter(fn);
}
```

As the first step we need to we have to define the properties of this problem.

- After any filter invocation the length of the returned array will be equal or less
- After any filter invocation the elements of the resulting array are contained in the original one
- filter (with the same `fn` argument) is idempotent, which means multiple invocations will not change the result
- filter should be independent of the order of elements regarding the length of the resulting array

### jsverify


